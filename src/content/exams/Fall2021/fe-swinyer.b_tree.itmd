<%
bulk_data = [[ 1, 12, 2, 11, 3, 10, 4, 9 , 5, 8, 6, 7],
             [ 10, 25, 11, 24, 12, 23, 13, 22, 14, 21, 15, 20, 16, 19, 17, 18],
             [ 4, 23, 5, 22, 6, 21, 7, 20, 8, 19, 9, 18, 10, 17, 11, 16, 12, 15, 13, 14],
             [ 8, 31, 9, 30, 10, 29, 11, 28, 12, 27, 13, 26, 14, 25, 15, 24, 16, 23, 17, 22, 18, 21, 19, 20]]
for index in range(len(bulk_data)):
   assert len(bulk_data[index]) == 4 * (index+3)
   assert len(bulk_data[index]) == len(set(bulk_data[index]))
end
%>
## {{!linkable_header('B trees')}} {{points_b_tree}} points

In this section, you will show your knowledge of bulk loading a B$^+$ tree.

**Calculator.B.Tree:** You may use this box as a calculator.
Just type in any expression that can be evaluated by a JavaScript eval.
For example, `2 ** 0.5` will show you the result of the square root of 2
in the red box to the right.
`log(10)` will show the natural log of 10 in the red box to the right.
Lastly, you may want to utilize the log identity of $\log_x{y} = \log{y}/\log{x}$.
Leaving the box empty or filled in will **NOT** affect your grade.
{{!calculator(name=f'_calculator_b_tree')}}

% for index in range(number_b_tree):
  % if section == '003' or (member_number % number_b_tree) == index:
    % include('viewAnswer', answer=f' Only seen by students number member_number % {number_b_tree} == {index}')

   **B.Tree.{{index+1}}:** Assume you have to bulk load a B$^+$ tree using the algorithm from the book.
   Each index page or node in the B$^+$ tree can contain 5 index entries.
   Each data page or leaf node can contain {{index+3}} tuples.  
   Further assume that the keys for the bulk data load are the following integers: {{', '.join([f'{x}' for x in bulk_data[index]])}}  
   In the table below, select the index entries in the root index node.
   If an index entry is unused, leave it blank.
   <%
   sorted_bulk_data = sorted(bulk_data[index])
   symbols = [f'{x}' for x in range(sorted_bulk_data[0]-1, sorted_bulk_data[-1]+1)] + ['']
   answer = [ f'{sorted_bulk_data[index+3]}',
              f'{sorted_bulk_data[2*(index+3)]}',
              f'{sorted_bulk_data[3*(index+3)]}',
              '',
              '']
   assert sorted_bulk_data[index+2] + 1 == sorted_bulk_data[index+3]
   assert sorted_bulk_data[2*(index+3)-1] + 1 == sorted_bulk_data[2*(index+3)]
   assert sorted_bulk_data[3*(index+3)-1] + 1 == sorted_bulk_data[3*(index+3)]
   answer2 = f''' Since after sorting, the {index+3}rd element has the value {sorted_bulk_data[index+2]},
the {index+4} element has the value {sorted_bulk_data[index+3]},
the first entry in the root has to be {sorted_bulk_data[index+3]}
All other entries follow
Answer {answer}'''
   %>
   {{!table(inputs=1, headings='Position,Index value', table=f'''
Index entry 1,{answer[0]}
Index entry 2,{answer[1]}
Index entry 3,{answer[2]}
Index entry 4,{answer[3]}
Index entry 5,{answer[4]}''', symbols=symbols, points=5, name=f'B.Tree.{index+1}')}}
   % include('viewAnswer', answer=answer2)

  % end  # section == 003 or member_number%number_b_tree == index
% end  # for index in range(number_b_tree)
