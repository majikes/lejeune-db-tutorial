---
title: {{TITLE}}
theme: "comp421"
separator: "^---"
verticalSeparator: "^----"
notesSeparator: "^Note:"
revealOptions:
    transition: fade


---

### Today's class

- Course evaluation submission rate as of 10:00 PM Monday, 42%

- By the end of class you should know
  - Transaction Concept
  - Transaction State
  - Concurrent Executions
  - Serializability
  - Recoverability

Note:

We don't cover 

  - Implementation of Isolation
  - Transaction Definition in SQL
  - Testing for Serializability.


---

### Transaction Concept

- A **transaction** is a <i>unit </i>of program execution that accesses and possibly updates various data items.
- E.g. transaction to transfer $50 from account A to account B:
  1. **read**(<i>A</i>)
  2. <i> A</i> := <i>A –</i> 50
  3. **write**(<i>A</i>)
  4. **read**(<i>B</i>)
  5. <i> B</i> := <i>B + </i>50
  6. **write**(<i>B)</i>
- Two main issues to deal with:
  - Failures of various kinds, such as hardware failures and system crashes
  - Concurrent execution of multiple transactions


---

### Example of Fund Transfer

- Same transaction to transfer $50 from account A to B:
- **Atomicity requirement**
  - If the transaction fails after step 3 and before step 6, money will be “lost” leading to an inconsistent database state
    - Failure could be due to software or hardware
  - The system should ensure that updates of a partially executed transaction are not reflected in the database
- **Durability requirement** — once the user has been notified that the transaction has completed (i.e., the transfer of the $50 has taken place), the updates to the database by the transaction must persist even if there are software or hardware failures.

Note:

Atomicity is the A in ACID  
Durability is the D in ACID  

---

### Example of Fund Transfer (Cont.)

- **Consistency requirement** in above example:
  - Sum of accounts A and B unchanged by the transaction
- Consistency requirements include 
  - IC such as primary keys and foreign keys
  - Implicit integrity constraints
    - Account balances minus loads equal cash-on-hand
  - A transaction must see a consistent database
  - During transaction DB may be temporarily inconsistent
  - When transaction completes database must be consistent
    - Erroneous transaction logic leads to inconsistency

Note:

Consistency is the C in ACID

---

### Example of Fund Transfer (Cont.)

<ul>
 <li> <b>Isolation requirement</b> — Allow Transaction T2 access to partially updated DB<ul>
  <li>inconsistent database: sum $A+B$ less than should be</li></ul></li><div class="row">
 <li><div class="twocolumns">
  <br/>T1
  <br/><b>read</b>(A); A -= 50; <b>write</b>(A)
  <br/>
  <br/><b>read</b>(B); A += 50; <b>write</b>(B)
 </div> 
 <div class="twocolumns">
  <br/>T2
  <br/>
  <br/> <b>read</b>(A), <b>read</b>(B), print(A+B)
  <br/>
  <br/>
 </div>
</div></li>
<li> Isolation ensured trivially when running transactions <b>serially</b><ul>
<li> However executing transactions concurrently has significant benefits</li>
</ul>

Note:

Isolation or running each transaction serially is a trivial solution

---

### ACID Properties

- **Atomicity** Either all transaction's operations properly reflected in DB or none are
- **Consistency** Transaction's execution in isolation preserves the consistency of the DB
- **Isolation** Transactions may execute concurrently, but each must be unaware of others concurrently executing transactions.
  - Intermediate transaction results must be hidden from other concurrently executed transactions.
  - For every transaction pair $T_i$ and $T_j$, it appears to $T_i$ that either $T_j$, finished execution before $T_i$ started, or $T_j$ started execution after $T_i$ finished
- **Durability** After transaction completes successfully, its changes to the DB persist, even if system failures


---

### Transaction State

- **Active** – initial state; transaction stays active while executing
- **Partially committed** – After the final statement executed
- **Failed** -- after discovery that normal execution must stop
- **Aborted** – after the transaction rolled back and DB restored to state prior to transaction start.  Options abort:
  1. restart the transaction
     - can be done only if no internal logical error
  2. kill the transaction
- **Committed** – after successful completion.

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.1.State-diagram-of-a-transaction.png" style="width:20%"/>
 <figcaption>Figure 17.1 State diagram of a transaction</figcaption>
</figure>


---

### Concurrent Executions

- Advantages of concurrent execution:
  - **Increased processor and disk utilization**: better transaction throughput
    - One transaction uses CPU; another reading / writing disk
  - **Reduced average response time** for transactions
    - Short transactions need not wait behind long ones.
- **Concurrency control schemes** – mechanisms  to achieve isolation
  - Control interaction among concurrent transactions to prevent inconsistent DB


---

### Schedules

- **Schedule** – a sequences of instructions that specify the chronological order in which instructions of concurrent transactions are executed
  - Must consist of all instructions of those transactions
  - Must preserve the order within each individual transaction
- Successful transaction has commit for last statement
  - By default transaction have commit instruction
- A transaction that fails to successfully complete its execution will have an abort instruction as the last statement

---

### Grades page implied commit

- Get cursor before and commit after grades page transaction

```Python
@with_db_cursor  # Get cursor for grades page
def grades(cursor):
   ...
```

```Python
def with_db_cursor(func):
     def func_wrapper(*args, **kwargs):
        connection = open_db()
        with contextlib.closing(connection):
           cursor = connection.cursor()
           result = func(*args, **dict(kwargs, cursor=cursor))
           connection.commit()
           return result

     return func_wrapper
```

Note:

Ask students if they want to see other pages

For example, what to do if grades is invoked by someone not in the class?  
not_found() has to commit

---


### Schedule 1

- $T_1$ transfers 50 dollars from A to B, and $T_2$ transfer 10% of the balance from A to B.
- A serial schedule in which $T_1$ is followed by $T_2$:

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.2.Serial-transaction-T1-first.png" style="width:35%"/>
 <figcaption>Figure 17.2 Serial transaction T<sub>1</sub> first</figcaption>
</figure>

Note:

This is what serial transactions look like

---

### Schedule 2

- A serial schedule where $T_2$ is followed by $T_1$

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.3.Serial-transaction-T2-first.png" style="width:35%"/>
 <figcaption>Figure 17.3 Serial transaction T<sub>2</sub> first</figcaption>
</figure>

---

### Schedule 3

- Let $T_1$ and $T_2$ be the transactions defined previously. The following schedule is not a serial schedule, but it is <i>equivalent</i> to Schedule 1.

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.4.concurrent-transaction.png" style="width:25%"/>
 <figcaption>Figure 17.4 Concurrent transaction</figcaption>
</figure>

In Schedules 1, 2 and 3, the sum A + B is preserved

---

### Schedule 4

- The following concurrent schedule does not preserve the value of (A + B)

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.5.inconsistent.state.png" style="width:35%"/>
 <figcaption>Figure 17.5 Inconsistent state</figcaption>
</figure>



---

### Serializability

- **Basic Assumption** – Each transaction preserves DB consistency
  - Serial execution any transaction set preserves DB consistency
- A concurrent schedule is serializable if equivalent to a serial schedule
  - Different forms of schedule equivalence give rise to:
    1. **conflict serializability**
    2. **view serializability**

Note:

Section 17.6

---

### Simplified view of transactions

- Ignore operations other than **read** and **write** instructions
- Assume transactions perform arbitrary computations on data between reads and writes
- Simplified schedules only consists of **read** / **write** 


---

### Conflicting Instructions 

- Instructions $l_i$ and $l_j$ of transactions $T_i$ and $T_j$ respectively, **conflict** $\leftrightarrow \exists$ some item $Q$ accessed by both $l_i$ and $l_j$, and at least one of these instructions wrote $Q$
  1. $l_i$ = **read**(Q),  $l_j$ = **read**(Q). $l_i$ and $l_j$ don't conflict
  2. $l_i$ = **read**(Q),  $l_j$ = **write**(Q).  They conflict
  3. $l_i$ = **write**(Q), $l_j$ = **read**(Q).   They conflict
  4. $l_i$ = **write**(Q), $l_j$ = **write**(Q).  They conflict
- A conflict between $l_i$ and $l_j$ forces temporal order between them
  - If $l_i$ and $l_j$ are consecutive but do not conflict
    - Results same even if interchanged in schedule


---

### Conflict Serializability

- Let's define some serializability terms
  - If a schedule $S$ can be transformed into a schedule $S^\prime$ by a series of swaps of non-conflicting instructions, we say that $S$ and $S^\prime$ are **conflict equivalent**.
  - A schedule $S$ is **conflict serializable** if it is conflict equivalent to a serial schedule


---

### Conflict Schedule 5

- Schedule 3 can be transformed into Schedule 5 by swapping $T_2$ **write**(A) with $T_1$ **read**(B)

<div class="rows">
 <div class="twocolumns">
  <figure style="border: 0">
   <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.6.Schedule-3.png"/>
   <figcaption>Schedule 3</figurecap>
  </figure>
 </div> 
 <div class="twocolumns">
  <figure style="border: 0">
   <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.7.Schedule-5.png"/>
   <figcaption>Schedule 5</figurecap>
  </figure>
 </div> 
</div>

---

### Conflict Serializability (Cont.)

- Schedule 3 can be transformed into Schedule 6, a serial schedule where $T_2$ follows $T_1$, by series of swaps of non-conflicting instructions.  Therefore Schedule 3 is conflict serializable.

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Schedule-3-schedule-6.png" style="width:75%"/>
</figure>


---

### Conflict Serializability (Cont.)

- Example of a schedule that is not conflict serializable:

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.9.Schedule-7.png" style="width:65%"/>
 <figcaption>Figure 17.9 Schedule 7</figcaption>
</figure>

- We are unable to swap instructions in the above schedule to obtain either the serial schedule &lt; $T_3$, $T_4$ &gt;, or the serial schedule &lt; $T_4$, $T_3$ &gt;


---

{{HIDDEN}}

### View Serializability

- Let $S$ and $S^\prime$ be two schedules with the same set of transactions.  $S$ and $S^\prime$ are **view equivalent** if the following three conditions are met, for each data item $Q$,
  1. If $S$, $T_i$ reads the initial value of $Q$, then in schedule $S^\prime$ also $T_i$ must read the initial value of $Q$.
  2. If $S$ $T_i$ executes **read**(Q), and that value was produced by $T_j$ (if any), then in schedule $S^\prime$ also $T_i$ must read the value of $Q$ that was produced by the same **write**(Q) operation of $T_j$
  3. The transaction (if any) that performs the final **write**(Q) operation in schedule $S$ must also perform the final **write**(Q) operation in schedule $S^\prime$
- As can be seen, view equivalence is also based purely on **reads** and **writes** alone.


---

{{HIDDEN}}

### View Serializability (Cont.)

- A schedule $S$ is **view serializable** if it is view equivalent to a serial schedule.
- Every conflict serializable schedule is also view serializable.
- Below is a schedule which is view-serializable but <i>not </i>conflict serializable
- What serial schedule is above equivalent to?
- Every view serializable schedule that is not conflict serializable has **blind writes**


---

{{HIDDEN}}

### Other Notions of Serializability

- The schedule below produces same outcome as the serial schedule &lt; $T_1$,<i> T</i>5 &gt;, yet is not conflict equivalent or view equivalent to it.
- Determining such equivalence requires analysis of operations other than read and write


---

{{HIDDEN}}

### Testing for Serializability

- Consider some schedule of a set of transactions $T_1$, $T_2$, ..., <i>T</i><i>n</i>
- **Precedence graph** — a direct graph where the vertices are the transactions (names)
- We draw an arc from $T_i$ to $T_j$ if the two transaction conflict, and $T_i$ accessed the data item on which the conflict arose earlier
- We may label the arc by the item that was accessed.
- <b>Example 1</b>


---

{{HIDDEN}}

### Test for Conflict Serializability

- A schedule is conflict serializable if and only if its precedence graph is acyclic
- Cycle-detection algorithms exist which take order <i>n</i><sup>2</sup><sup> </sup>time, where <i>n </i>is the number of vertices in the graph.
  - (Better algorithms take order <i>n</i> + <i>e</i> where $e$ is the number of edges.)
- If precedence graph is acyclic, the serializability order can be obtained by a <i>topological sorting</i> of the graph. 
  - This is a linear order consistent with the partial order of the graph
  - For example, a serializability order for 
<p>Schedule A would be</p>
<p><i>T</i>5 →<i> T</i>1 →<i> T</i>3 →<i> T</i>2 →<i> T</i>4</p>
    - Are there others?


---

{{HIDDEN}}

### Test for View Serializability

- The precedence graph test for conflict serializability cannot be used directly to test for view serializability
  - Extension to test for view serializability has cost exponential in the size of the precedence graph
- The problem of checking if a schedule is view serializable falls in the class of <i>NP</i>-complete problems.
  - Thus. existence of an efficient algorithm is <i>extremely</i> unlikely.
- However practical algorithms that just check some **sufficient** **conditions** for view serializability can still be used.


---

### Recoverable Schedules

- **Recoverable schedule** — if $T_j$ reads data item previously written by $T_i$
  - $T_i$'s commit must occur before the commit operation of $T_j$
- The following schedule (Schedule 11) is not recoverable<div class="row">
<div class="twocolumns">
 <figure style="border: 0">
  <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.14.Schedule.9.png" style="width:25%"/>
  <figcaption>Figure 17.14 Schedule 9</figcaption>
 </figure>
</div>
<div class="twocolumns">
<ul><li>If T<sub>8</sub> should abort, T<sub>9</sub> would have read (displayed to user?) inconsistent DB state.</li>
<li>DB must ensure schedules are recoverable.</li>
<li>Need to address effect failures on concurrently running transactions</li>
</ul>
</div>
</div>


---

### Cascading Rollbacks

- **Cascading rollback** – a single failure leads to series rollbacks
  - Consider the following:
  - If $T_{10}$ failes, $T_{11}$ and $T_{12}$ must be rolled back

<figure style="border: 0">
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.17.Figure.17.15.Schedule.10.png" style="width:50%"/>
 <figcaption>Figure 17.15 Schedule 10</figcaption>
</figure>

Note:

---

### Cascadeless Schedules

- **Cascadeless schedules** — cascading rollbacks cannot occur
  - For each pair of transactions $T_i$ and $T_j$ such that $T_j$ reads a data item  previously written by $T_i$, the commit operation of $T_i$ appears before the  read operation of $T_j$.
- Every cascadeless schedule is also recoverable
- DB restricts schedules to those that are cascadeless

Note:

So how do you do this?

Concurrency control

---

### Concurrency Control

- DB **must** provide a mechanism that will ensure that all  possible schedules are 
  - either conflict serializable, and 
  - are recoverable or preferably cascadeless
- A policy in which only one transaction can execute at a time  generates serial schedules, but provides a poor degree of  concurrency
  - Are serial schedules recoverable/cascadeless?
- Testing a schedule for serializability <i>after</i> it has executed is a little too  late!
- **Goal** – to develop concurrency control protocols that will assure  serializability.


---

{{HIDDEN}}

### Concurrency Control (Cont.)

- Schedules must be conflict or view serializable, and recoverable, for  the sake of database consistency, and preferably cascadeless.
- A policy in which only one transaction can execute at a time  generates serial schedules, but provides a poor degree of  concurrency.
- Concurrency-control schemes tradeoff between the amount of  concurrency they allow and the amount of overhead that they incur.
- Some schemes allow only conflict-serializable schedules to be  generated, while others allow  view-serializable schedules that are not  conflict-serializable.


---

{{HIDDEN}}


### Concurrency Control vs. Serializability Tests

- Concurrency-control protocols allow concurrent schedules, but ensure  that the schedules are conflict/view serializable, and are recoverable  and cascadeless .
- Concurrency control protocols (generally) do not examine the  precedence graph as it is being created
  - Instead a protocol imposes a discipline that avoids non-serializable  schedules.
  - We study such protocols in Chapter 16.
- Different concurrency control protocols provide different tradeoffs  between the amount of concurrency they allow and the amount of  overhead that they incur.
- Tests for serializability help us understand why a concurrency control  protocol is correct.   


---

{{HIDDEN}}


### Weak Levels of Consistency

- Some applications are willing to live with weak levels of consistency,  allowing schedules that are not serializable
  - E.g., a read-only transaction that wants to get an approximate total  balance of all accounts 
  - E.g., database statistics computed for query optimization can be  approximate (why?)
  - Such transactions need not be serializable with respect to other  transactions
- Tradeoff accuracy for performance


---

{{HIDDEN}}


### Levels of Consistency in SQL

<img src="©.jpg"/>
<p><b>-</b></p>
<img src="ª.jpg"/>
<p><b>92</b></p>
- **Serializable** — default
- **Repeatable read** — only committed records to be read. 
  - Repeated reads of same record must return same value.
  - However, a transaction may not be serializable – it may find some records  inserted by a transaction but not find others.
- **Read committed** — only committed records can be read.
  - Successive reads of record may return different (but committed) values.
- **Read uncommitted** — even uncommitted records may be read. 


---

{{HIDDEN}}


### Levels of Consistency

- Lower degrees of consistency useful for gathering approximate information about the database 
- Warning: some database systems do not ensure serializable  schedules by default
- E.g., Oracle (and PostgreSQL prior to version 9) by default support a  level of consistency called snapshot isolation (not part of the SQL  standard)


---

{{HIDDEN}}


### Transaction Definition in SQL

- In SQL, a transaction begins implicitly.
- A transaction in SQL ends by:
  - **Commit work** commits current transaction and begins a new one.
  - **Rollback work** causes current transaction to abort.
- In almost all database systems, by default, every SQL statement also  commits implicitly if it executes successfully
  - Implicit commit can be turned off by a database directive
    - E.g., in JDBC -- connection.setAutoCommit(false);
- Isolation level can be set at database level
- Isolation level can be changed at start of transaction
    - E.g.  In SQL **set transaction isolation level serializable**
    - E.g. in JDBC -- connection.setTransactionIsolation(       Connection.TRANSACTION_SERIALIZABLE)


---

{{HIDDEN}}


### Implementation of Isolation Levels

<p>Overview</p>
- Locking
  - Lock on whole database vs lock on items
  - How long to hold lock?
  - Shared vs exclusive locks
- Timestamps
  - Transaction timestamp assigned e.g. when a transaction begins
  - Data items store two timestamps
    - Read timestamp
    - Write timestamp
  - Timestamps are used to detect out of order accesses
- Multiple versions of each data item
  - Allow transactions to read from a “snapshot” of the database


---

{{HIDDEN}}


### Transactions as SQL Statements

- E.g. Transaction 1:
<p><b>select</b><i> ID, name  </i><b>from  </b><i>instructor   </i><b>where</b><i> salary</i> &gt; 90000</p>
- Transaction 2:
<p><b>insert into</b><i> instructor</i><b> values</b> ('11111', 'James', 'Marketing', 100000)</p>
- Suppose 
  - T1 starts, finds tuples salary &gt; 90000 using index and locks them
  - And then T2 executes.  
  - Do T1 and T2 conflict?  Does tuple level locking detect the conflict?
  - Instance of the <b>phantom phenomenon</b>
- Also consider T3 below, with Wu’s salary = 90000 
<p><b>update</b><i> instructor</i></p>
<p><b>set</b><i> salary</i> = <i>salary</i> * 1.1</p>
<p><b>where</b><i> name</i> = 'Wu’ </p>
- Key idea:  Detect “<b>predicate</b>” conflicts, and use some form of   “<b>predicate locking</b>”

---

### Epilogue

- DB provides concurrency
- DB appears serialized
- DB handles recoverability
