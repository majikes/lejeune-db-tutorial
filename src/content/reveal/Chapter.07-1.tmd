---
title: {{TITLE}}
theme: "comp421"
separator: "^---"
verticalSeparator: "^----"
notesSeparator: "^Note:"
revealOptions:
    transition: fade

---

### Today's class

Chapter 7:  Normalization

- By the end of class you should know
  - Features of Good Relational Design
  - Functional Dependencies
  - Decomposition Using Functional Dependencies
  - Normal Forms

- Homework 5 will be available after class and due 12/5 11:59:59 PM
  - It is an optional homework
  - Your lowest homework will be dropped so you don't have to do this one
  
Note:

Today we will cover 7.1 through 7.3

---

### Features of Good Relational Designs

- Suppose we combine _instructor_ and _department_ into <i>in_dep</i>
  - Represents natural join on instructor &amp; department
<img src="{{HTTPS_FQDN}}/static/images/Chapter.07.In_Dept_Relation.jpg" style="width:50%"/>
- Repetition of information
- Requires null values if new depart w/ no instructors

---

### Decomposition

- The only way to avoid the repetition-of-information problem in the in_dep schema $\rightarrow$ decompose into two schemas – instructor and department
- Not all decompositions are good.  Suppose we decompose
  <br/>{{TAB}}<i>employee(ID, name, street, city, salary)</i> 
  <br/><b>into</b>
  <br/>{{TAB}}<i>employee1</i> (<i>ID</i>, <i>name</i>) 
  <br/>{{TAB}}<i>employee2</i> (<i>name</i>, <i>street, city, salary</i>) 
  - What if two employees have the name John Smith?
- The next slide shows how we lose information 
  - If cannot reconstruct the original <i>employee</i> relation
  - Then it's called a <b>lossy decomposition</b>

Note:

Loss-y decomposition is when you loss information

---

### A Lossy Decomposition

<figure>
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.07.LossyDecomposition.png" style="width:50%"/>
</figure>

- The top, original relation is different when its two decompositions are joined into the lower, resulting relation
  
Note:

If we break up first relation into two relations,  
when we join them back we get extra tuples

---

### Lossless Decomposition

- Let $R$ relation schema
  - Let $R_1$ and $R_2$ form a decomposition of $R$
  - That is $R = R_1 \cup R_2$
- The decomposition is a **lossless decomposition** if
  - No loss of info by replacing $R$ with $R_1 \cup R_2$
  - $r = \Pi_{R_1}(r)$ $\bowtie$ $\Pi_{R_2}(r)$
- Conversely, a lossy decomposition
  - $r \subset \Pi_{R_1}(r)$ $\bowtie$ $\Pi_{R_2}(r)$

Note:

The original relation and relation reconstructed from joining decomposed relations must contain same number of tuples if number is increased or decreased then it is Lossy Join decomposition

Note that the last line is r is a subset, not equal
---

### Example of Lossless Decomposition 

- Decompose $R = (A, B, C)$ into $R_1 = (A, B)$ $R_2 = (B, C)$

<img src="{{HTTPS_FQDN}}/static/images/Chapter.07.Example.LosslessDecomposition.jpg" style="width:50%"/>

Note:

Notice that A is the only attribute in both decomposed relations.  
The natural join of $R_1$ $R_2$ is identical to R

A lossless decomposition

---

### Normalization Theory

- Decide whether a particular relation $R$ is in “good” form
- In the case that a relation $R$ is not in “good” form,  decompose it into set of relations {$R_1, R_2, \dots R_n$} such  that 
  - Each relation is in good form 
  - The decomposition is a lossless decomposition
- How is this done?
  - Our theory is based on:
    - functional dependencies
    - multivalued dependencies

Note:

Let's take a high-level look at normalization theory.


---

### Functional Dependencies

- There are constraints (rules) on the data  in the real world.
- For example, some of the university constraints are:
  - Students &amp; instructors have unique IDs
  - Each student &amp; instructor has only one name.
  - Each instructor is primarily associated with only one department.
  - Each student is primarily associated with only one department.
  - Each department has only one value for its budget.
  - Each department is only one associated with one building.


---

### Functional Dependencies (Cont.)

- A relation instance that satisfies all such real-world constraints is called a <b>legal instance </b>of the relation
- A DB legal instance is one where all the relation instances are legal
- Constraints on the set of legal relations.
- Require that the value for a certain set of attributes determines uniquely the value for another set of attributes.
- A functional dependency is a generalization of the notion of a <i>key.</i>

---

### Functional Dependencies Definition 

- Let $R$ be a relation schema $\alpha \subseteq R$ and $\beta \subseteq R$
- The <b>functional dependency</b> 
<br/>{{TAB}}$\alpha \rightarrow \beta$
<br/><b>holds on</b> $R$ iff for any legal relations $r(R)$, whenever any two tuples <i>t</i>1 and <i>t</i>2 of <i>r</i> agree on the attributes $\alpha$, they also agree on the attributes $\beta$<i>. </i>That is, 
<br/>{{TAB}}<i>t</i>1[$\alpha$] = <i>t</i>2 [$\alpha$]   ⇒ <i>t</i>1[$\beta$]  = <i>t</i>2 [$\beta$] 
- Example:  Consider <i>r</i>(A<i>,B </i>) with the following instance of <i>r.</i>
  <table border="1">
   <tr><th>A</th><th>B</th></tr>
   <tr><td>1</td><td>4</td></tr>
   <tr><td>1</td><td>5</td></tr>
   <tr><td>3</td><td>7</td></tr>
  </table>
- On this instance, <i>B</i> →<i> A</i> hold;  <i>A</i> →<i> B</i> does <b>NOT</b> hold

Note:

$\alpha$ and $\beta$ are attributes in relation R

---

### Closure of a Set of Functional Dependencies

- Given a set $F$ set of functional dependencies, there are  certain other functional dependencies that are logically  implied by $F$.
  - If $A \rightarrow B$ and $B \rightarrow C$, then we can infer that $A \rightarrow C$
  - etc.
- **Closure of F**: set of **all** functional dependencies logically implied by $F$.
- We denote the closure of $F$ by **$F^+$**

Note:

A $\rightarrow$ B, B $\rightarrow$ C, then A $\rightarrow$ C is the transitive property

Knowing the closure of F, $F^+$ is helpful to completing decompositions

---

### Keys and Functional Dependencies
#### Differences

- Keys
  - $K$ is a superkey for relation schema $R$ if and only if $K \rightarrow R$
  - $K$ is a candidate key for $R$ if and only if 
    - $K \rightarrow R$, and
    - for no $\alpha \subset K$, $\alpha \rightarrow R$
- Functional dependencies more expressive than superkeys! Consider:
<br/>{{TAB}}<i>in_dep</i> (<i>ID, name, salary, dept_name, building, budget </i>)<i>.</i>
  - Expect functional dependencies:
    - {{TAB}}<i>dept_name</i> $\rightarrow$  <i>building</i>
    - {{TAB}}<i>ID</i> $\rightarrow$ <i> building</i>
  - Do not expect dependencies:
    - {{TAB}}<i>dept_name</i> $\rightarrow$ <i>salary</i>

Note:

You probably know what a superkey, candidate key, and primary key are.  
Candidate key is potentially a primary key.  
Why learn about functional dependencies?  

FD useful for decomposition

---

### Use of Functional Dependencies

- We use functional dependencies to:
  - Test relation instances to see if they are legal
    - $r$ **satisfies** $F$ if relation $r$ is legal under set $F$
  - To specify constraints on the set of legal relations
    - $F$ **holds on** $R$ if all legal $r$ satisfies $F$
- **Note**: A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does  not hold on all legal instances.  
  - For example, a specific instance of _instructor_ may, by chance, satisfy
<br/>{{TAB}}<i>name</i> $\rightarrow$ <i>ID</i>
   - But not in the general case!

Note:

Satisfies says that one instance of a relation is legal under $F$  
Holds implies all legal R satisfies F  

Don't get confused if a particular instance happens to satisfy F  

---

### Trivial Functional Dependencies

- **Trivial** functional relations are satisfied by all relations.
  - Example:
    - <i>ID, name</i> $\rightarrow$ <i>ID</i>
    - <i>name</i> $\rightarrow$ <i>name</i>
  - In general, $\alpha \rightarrow \beta$ is trivial if $\beta \subseteq \alpha$

Note:

Let's start out by defining a trivial dependency

---

### Lossless Decomposition

- Use functional dependencies (FDs) to show decomposition is lossless.  
- For $R = (R_1, R_2)$, require all possible $r$ on schema $R$:
<br/>{{TAB}}$r = \Pi_{R_1}(r)$ $\bowtie$ $\Pi_{R_2}(r)$
- Decomposition $R$ into $R_1$ and $R_2$ lossless decomposition if either in $F^+$:
  - $R_1 \cap R_2 \rightarrow R_1$
  - $R_1 \cap R_2 \rightarrow R_2$
- If $R_1 \cap R_2 \rightarrow R_1$ then:
  - $R_1 \cap R_2$ is the primary key of $r_1$
  - $R_1 \cap R_2$ is a foreign key form $r_2$ referencing $r_1$

Note:

For it to be lossless for bisection into two relations, either  
$R_1 \cap R_2$ is a key to $R_1$ or the other way around.

---

{{HIDDEN}}

### Example

- $R = (A, B, C)$, $F = (A \rightarrow B, B \rightarrow C)$
- $R_1 = (A, B)$, $R_2 = (B, C)$
  - Lossless decomposition: <br />$R_1 \cap R_2$ = { $B$ } and $B \rightarrow BC$
- $R_1 = (A, B)$, $R_2 = (A, C)$
  - Lossless decomposition:<br />$R_1 \cap R_2 =$ { $A$ } and $A \rightarrow AB$
- <i>Note</i>
  - $B \rightarrow BC$<br/>is a shorthand notation for
  - $B \rightarrow \{B, C\}$


---

### Dependency Preservation

- Testing FD constraints against each DB update costly
- Useful design DB s.t. constraints tested efficiently  
- If FD tested using one relation/notation, testing is efficient
- Introduce Normal Forms


---

{{HIDDEN}}

### Dependency Preservation Example

- Consider a schema:
<br/>{{TAB}}<i>dept_advisor(s_ID, i_ID, department_name</i>)
- With function dependencies:
<br/>{{TAB}}<i>i_ID</i> →<i> dept_name</i>
<br/>{{TAB}}<i>s_ID, dept_name</i> →<i> i_ID</i><
- In the above design we are forced to repeat the department  name once for each time an instructor participates in a  <i>dept_advisor</i> relationship.  
- To fix this, we need to decompose <i>dept_advisor</i>
- Any decomposition will not include all the attributes in
<br/>{{TAB}}<i>s_ID, dept_name</i> →<i> i_ID</i>
- Thus, the composition NOT be dependency preserving 


---

### First Normal Form (1NF)

- [1NF](https://en.wikipedia.org/wiki/First_normal_form): each attribute contains atomic values
  - No lists or sets
- Violations
  - Having a list for attribute phone_numbers
  - Try listing students with specific phone number
  - Update a phone number within a list of numbers.
- Lists and sets are painful to manage
  - Separate them into rows of another relation phones
  - primary key might contain the student ID

Note:

Examples of this might be subsequent submissions.   
You could get an A, A, B, etc.

You'd want to break this up into separate tables

---

### Second Normal Form (2NF)

- [2NF](https://en.wikipedia.org/wiki/Second_normal_form): has to be in 1NF and every non-primary-key attribute is fully functionally dependent on the primary key
  - Consider relation student ID, course_id, cost<table><tr><th>ID</th><th>course_id</th><th>cost</th></tr>
  <tr><td>1</td><td>COMP 116</td><td>1000</td></tr>
  <tr><td>2</td><td>COMP 210</td><td>1500</td></tr>
  <tr><td>1</td><td>COMP 421</td><td>2000</td></tr>
  <tr><td>4</td><td>COMP 310</td><td>1000</td></tr>
  <tr><td>4</td><td>COMP 116</td><td>1000</td></tr>
  <tr><td>2</td><td>COMP 550</td><td>2000</td></tr></table>
  - cost is dependent on the course being taken
  - Separate cost into another relation costs
    - Primary key might be the course number


Note:

Another example is if you had data on stores: city, state, and revenue.  
Since Raleigh is always NC you might want to break out city/state to an address table or use a zip code

---

### Third Normal Form

- $R$ is in **third normal form (3NF)** if it is in 2NF and if for all $\alpha \rightarrow \beta$ in $F^+$ at least one of the following holds:
  1. $\alpha \rightarrow \beta$ is trivial ($\beta \subseteq \alpha$)
  1. $\alpha$ is a superkey for $R$
  1. Each attribute in $\beta - \alpha$ is contained in a $R$ candidate key
     - Each attribute may be in a different candidate key

Note:

Page 317 Section 7.3.2

All attributes are functionally dependent on the primary key

There are no transitive partial dependencies

---

### 3NF Example

- Consider a schema:
<br/>{{TAB}}<i>dept_advisor(s_ID, i_ID, dept_name</i>)
- With function dependencies:
<br/>{{TAB}}<i>i_ID</i> →<i> dept_name</i>
<br/>{{TAB}}<i>s_ID, dept_name</i> →<i> i_ID</i>
- Two candidate keys =  {<i>s_ID, dept_name</i>}, {<i>s_ID, i_ID</i> }
- $R$ is in  3NF
  - <i>s_ID, dept_name</i> is a superkey
  - <i>i_ID</i> $\rightarrow$ <i>dept_name</i> and <i>i_ID</i> is NOT a superkey, but:
     - { <i>dept_name</i>} – {<i>i_ID</i> } = {<i>dept_name</i>} and
     - <i>dept_name</i> is contained in one of the candidate keys

Note:

Each non-key has to be dependent on a candidate key or is in a superkey

The right side of a FD can be a prime-attribute

In this case $\alpha =$ i_id, $\beta =$ dept_name and $\beta - \alpha =$dept_name

dept_name is contained in some candidate key and therefore dept_advisor is in 3NF

---

### Redundancy in 3NF

- Consider the schema R below, which is in 3NF :
  - R = (J, K, L)
  - F = { JK $\rightarrow$ L, L $\rightarrow$ K}
  - And and instance table:<figure>
<img src="{{HTTPS_FQDN}}/static/images/Chapter.07.Redundancy.in.3NF.png" style="width:25%"/>
<figcaption>Instance of R</figcaption>
</figure>
- What is wrong with the table?
  - Repetition of $L_1$ with $L \rightarrow K$
  - Null J can't be for $JK \rightarrow L$

Note:

If the value of L depends on JL.  
Any combination of JK should have unique values of L  

But $l_1$ has values JK of {$j_1, 
  - Repetition of $l_1$
  - Given the null value in J, $(l_2, k_2)$ has no relationship to $J$


---

### Boyce-Codd Normal Form

- A relation schema $R$ is in BCNF with respect to a set $F$ of  functional  dependencies if for all functional dependencies in $F^+$ of the form 
<br/>{{TAB}}$\alpha \rightarrow \beta$
<br />where $\alpha \subseteq R$ and $\beta \subseteq R$, at least one of the following holds:
  - $\alpha \rightarrow \beta$ is trivial (i.e., $\beta \subseteq \alpha$)
  - $\alpha$ is a superkey for $R$
- Each attribute must describe the key, the whole key, and nothing but the key
- If a relation schema R is in BCNF it is in 1NF, 2NF, and 3NF

Note:

page 314:

BCNF for $\alpha \rightarrow \beta$ either is true:  
 - $\alpha \rightarrow \beta$ is a trivial dependency
 - $\alpha$ is a superkey

Each attribute must describe the key, the whole key, and nothing but the key

Each tuple can be thought of as an entity or relations identified by a key and described by the remaining attributes.

BCNF each tuple can be thought of as an entity/relationship identified by a key described by remaining attributes.  

"Each attribute must describe the key, the whole key, and nothing but the key"

---

### Boyce-Codd Normal Form (Cont.)

- Example schema  that is <b><i>not</i></b> in BCNF:
<br/>{{TAB}}<i>in_dep</i> (<i>ID, name, salary, dept_name, building, budget </i>)
<br/>because :
   - From previous FD, in_dept,  dept_name $\rightarrow$ building, budget
     - but <i>dept_name</i> is not a superkey
- Better to decompose <i>in_dept</i> into _instructor_ and _department_ 
   - instructor is in BCNF
   - department is in BCNF

Note:

Department is not a superkey because a department could have many instructors with different ID's and names.

Make <code>in_dep(instructor, department)</code> is a better decomposition

---

### Decomposing a Schema into BCNF

- Let $R$ be a schema $R$ that is not in BCNF.  Let $\alpha \rightarrow \beta$ be the FD that causes a violation of BCNF.
- We decompose/replace $R$ into the following two schemas:
  - $\alpha \cup \beta$,  $R - ( \beta - \alpha )$
- In our example of in_dep, 
  - $\alpha$ = dept_name, $\beta$ = building, budget
  - in_dep = ($\alpha \cup \beta$) = ( dept_name, building, budget )
  - ( $R - ( \beta - \alpha)$ ) = ( ID, name, dept_name, salary )
- In our 2NF (ID, course_id, cost)
  - F = {ID $\rightarrow$ course_id, course_id $\rightarrow$ cost}
  - course_id $\rightarrow$ cost causes duplicate rows
  - $\alpha$ = course_id, $\beta$ = cost
  - $R_1 =$ (course_id, cost), $R_2$ = (ID, course_id)

Note:

So remember $\alpha \rightarrow \beta$ and $\alpha$ not a superkey

---

{{HIDDEN}}

### Check Decomposition Example

- $R = (A, B, C)$
<br />$F = (A \rightarrow B, B \rightarrow C)$
- $R_1 = (A, B)$, $R_2 = (B, C)$
  - Lossless-join decomposition:
<br/>{{TAB}}$R_1 \cap R_2 = ${ $B$ }
and $B \rightarrow BC$
  - Dependency preserving
- $R_1 = (A, B)$, $R_2 = (A, C)$
  - Lossless-join decomposition:
<br/>{{TAB}}$R_1 \cap R_2 = $ { $A$ } and $A \rightarrow AB$
  - Not dependency preserving 
<br/>(cannot check $B \rightarrow C$ without computing $R_1 \bowtie R_2$)

Note:

Let's check a relation of tuple A, B C and  
Functional dependency of $A \rightarrow B$, $B \rightarrow C$  

<font color='red'>Need to find in the book!!!</font>

---

### BCNF and Dependency Preservation

- Not always possible to achieve both BCNF and dependency preservation 
- Consider a schema where an instructor can act as an advisor for only a single department:
<br/>{{TAB}}<i>dept_advisor(s_ID, i_ID, department_name</i>)
- With function dependencies:
<br/>{{TAB}}<i>i_ID</i> →<i> dept_name</i>
<br/>{{TAB}}<i>s_ID, dept_name</i> →<i> i_ID</i>
- <i>dept_advisor</i> is not in BCNF 
<br/>{{TAB}}<i>i_ID</i> is not a superkey
- Any decomposition of <i>dept_advisor</i> will not include all the attributes in
<br/>{{TAB}}<i>s_ID, dept_name</i> →<i> i_ID</i>
- Thus, the composition is NOT be dependency preserving


---

### Comparison of BCNF and 3NF

- Advantages to 3NF over BCNF.  It is always possible to  obtain a 3NF design without sacrificing losslessness or  dependency preservation 
- Disadvantages to 3NF 
  - We may have to use null values to represent some of the  possible meaningful relationships among data items
  - There is the problem of repetition of information

Note:

In the real world, in my opinion, most databases are in 3NF

---

### Goals of Normalization

- Let $R$ be a relation scheme with a set $F$ of functional  dependencies
- Decide whether a relation scheme $R$ is in “good” form
- In the case that a relation scheme $R$ is not in “good” form
  - Decompose it into a set of relation scheme { $R_1$, $R_2$ $\dots$ $R_n$ } such that 
    1. Each relation scheme is in good form 
    2. The decomposition is a lossless decomposition
    3. Preferably, the decomposition should be dependency preserving


---

{{HIDDEN}} 

### How good is BCNF?

- There are database schemas in BCNF that do not seem to  be sufficiently normalized 
- Consider a relation 
<br/>{{TAB}}<i>inst_info (ID, child_name, phone)</i>
  - where an instructor may have more than one phone and  can have multiple children
  - Instance of <i>inst_info</i><table border="1">
<tr><th>ID</th><th>child_name</th><th>phone</th></tr>
<tr><td>99999</td><td>David</td><td>512-555-1234</td></tr>
<tr><td>99999</td><td>David</td><td>512-555-4321</td></tr>
<tr><td>99999</td><td>William</td><td>512-555-1234</td></tr>
<tr><td>99999</td><td>William</td><td>512-555-4321</td></tr>
</table>

Note:


Section 7.3.4 page 319

---

{{HIDDEN}} 

### How good is BCNF? (Cont.)

- There are no non-trivial functional dependencies and therefore the relation is in BCNF 
- Insertion anomalies
<br/>99999, David, 981-992-3443 to instructor 9999 Need to add two tuples:
  - (99999, David, 981-992-3443)
  - (99999, William, 981-992-3443)


---

{{HIDDEN}} 

### How good is BCNF? (Cont.)

- It is better to decompose <i>inst_info</i> into:
  - <i>inst_child</i>
  - <i>inst_phone</i>
- This suggests the need for higher normal forms, such as Fourth Normal Form (4NF)
    - <div class="row">
 <div class="twocolumns">
   <table>
    <tr><th>ID</th><th>child_name</tr>
    <tr><td>99999</td><td>David</td></tr>
    <tr><td>99999</td><td>William</td></tr>
   </table>
  </div>
  <div class="twocolumns">
   <table>
    <tr><th>ID</th><th>phone</th></tr>
    <tr><td>99999</td><td>512-555-1234</td></tr>
    <tr><td>99999</td><td>512-555-4321</td></tr>
   </table>
  </div>
</div>


---

### Chapter 7.1 through 7.3 Epilogu

- Should know how to tell if a schema is "good"
  - Should be able to tell how good!
- Should know what a functional dependency is
  - How to decompose relations with FD
- Should know BCNF and 3NF
