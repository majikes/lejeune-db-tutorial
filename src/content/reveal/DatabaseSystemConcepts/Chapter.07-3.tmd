---
title: {{TITLE}}
theme: "comp421"
separator: "^---"
verticalSeparator: "^----"
notesSeparator: "^Note:"
revealOptions:
    transition: fade

---

### Today's class

Chapter 7:  Multivalued dependencies

- By the end of class you should know
  - Decomposition Using Multivalued Dependencies 
  - More Normal Form
  - Atomic Domains and First Normal Form
  - Database-Design Process
  - Modeling Temporal Data

---

### Multivalued Dependencies (MVDs)

- Suppose we record names of children, and phone numbers for instructors:
  - <i> inst_child</i>(<i>ID</i>, <i>child_name</i>)
  - <i> inst_phone</i>(<i>ID</i>, <i>phone_number</i>)
- If we were to combine these schemas to get
  - <i> inst_info</i>(<i>ID</i>, <i>child_name</i>, <i>phone_number</i>)
  - Example data:
<p>(99999, David, 512-555-1234) (99999, David, 512-555-4321) (99999, William, 512-555-1234) (99999, William, 512-555-4321)</p>
- This relation is in BCNF
  - Why?


---

### Multivalued Dependencies

- Let $R$ be a relation schema and let \alpha \subseteq<i> R</i> and \beta \subseteq<i> R. </i>The <b>multivalued dependency</b> \alpha \rightarrow\rightarrow \beta holds on <i>R</i> if in any legal relation <i>r(R),</i> for all pairs for tuples  <i>t</i>1 and <i>t</i><i>2</i> in <i>r</i> such that <i>t</i>1[\alpha] = <i>t</i><i>2 </i>[\alpha], there exist tuples <i>t</i><i>3</i> and <i>t</i>4 in <i>r </i>such that:  <i>t</i>1[\alpha] = <i>t</i><i>2 </i>[\alpha] = <i>t</i>3 [\alpha] = <i>t</i>4 [\alpha]  <i>t</i>3[\beta]         =  <i>t</i>1 [\beta]  <i>t</i>3[<i>R  –</i> \beta] =  <i>t</i>2[<i>R  –</i> \beta]  <i>t</i>4 [\beta]         =  <i>t</i>2[\beta]  <i>t</i>4[<i>R  –</i> \beta] =  <i>t</i>1[<i>R  –</i> \beta] 


---

### MVD -- Tabular representation 

- Tabular representation of $\alpha \rightarrow\rightarrow \beta$ 
<img src="ã.jpg"/>


---

### MVD (Cont.)

- Let <i>R</i> be a relation schema with a set of attributes that are partitioned into 3 nonempty subsets. <i>Y, Z, W</i>
- We say that <i>Y </i>\rightarrow\rightarrow<i> Z </i>(<i>Y</i><b> multidetermines</b><i> Z </i>) if and only if for all possible relations <i>r </i>(<i>R </i>) &lt; <i>y</i>1, <i>z</i>1, <i>w</i>1 &gt; \in<i> r</i> and &lt; <i>y</i>1, <i>z</i>2, <i>w</i>2 &gt; \in<i> r</i> then &lt; <i>y</i>1, <i>z</i>1, <i>w</i>2 &gt; \in<i> r</i> and &lt; <i>y</i>1, <i>z</i>2, <i>w</i>1 &gt; \in<i> r</i>
- Note that since the behavior of <i>Z</i> and <i>W</i> are identical it follows that  <i>Y </i>\rightarrow\rightarrow<i> Z </i>if <i>Y</i> \rightarrow\rightarrow<i> W </i>


---

### Example

- In our example:
<p><i>ID </i>\rightarrow\rightarrow<i> child_name</i> <i>ID </i>\rightarrow\rightarrow<i> phone_number</i></p>
- The above formal definition is supposed to formalize the notion that given a particular value of <i>Y </i>(<i>ID</i>) it has associated with it a  set of values of <i>Z (child_name) </i>and a set of values of <i>W </i> <i>(phone_number)</i>, and these two sets are in some sense  independent of each other.
- Note: 
  - If <i>Y </i>\rightarrow<i> Z </i>then  <i>Y </i>\rightarrow\rightarrow<i> Z</i>
  - Indeed we have (in above notation) <i>Z</i>1<i> = Z</i>2 The claim follows.


---

### Use of Multivalued Dependencies

- We use multivalued dependencies in two ways: 
  1. To test relations to **determine** whether they are legal under  a given set of functional and multivalued dependencies
  2. To specify **constraints** on the set of legal relations.  We  shall concern ourselves <i>only</i> with relations that satisfy a  given set of functional and multivalued dependencies.
- If a relation <i>r</i> fails to satisfy a given multivalued dependency, we can construct a relations <i>r</i>′ that does satisfy the multivalued  dependency by adding tuples to $r$


---

### Theory of MVDs

- From the definition of multivalued dependency, we can derive the following rule:
  - If $\alpha \rightarrow \beta$, then $\alpha \rightarrow\rightarrow \beta$ That is, every functional dependency is also a multivalued  dependency
- The **closure** D<sup>+</sup>>of <i>D</i> is the set of all functional and multivalued dependencies logically implied by <i>D</i>.
  - We can compute D<sup>+</sup>>from <i>D</i>, using the formal definitions of functional dependencies and multivalued dependencies.
  - We can manage with such reasoning for very simple multivalued dependencies, which seem to be most common  in practice
  - For complex dependencies, it is better to reason about sets of dependencies using a system of inference rules  (Appendix C).


---

### Fourth Normal Form

- A relation schema <i>R</i> is in **4NF** with respect to a set <i>D</i> of functional and multivalued dependencies if for all multivalued  dependencies in <i>D</i><sup>+</sup>>of the form \alpha \rightarrow\rightarrow \beta, where \alpha \subseteq<i> R</i> and \beta \subseteq <i>R, </i>at least one of the following hold:
  - \alpha \rightarrow\rightarrow \beta is trivial (i.e., \beta \subseteq \alpha or \alpha \cup \beta<i> = R)</i>
  - \alpha is a superkey for schema <i>R</i>
- If a relation is in 4NF it is in BCNF


---

### Restriction of Multivalued Dependencies

- The restriction of  D to Ri is the set Di consisting of
  - All functional dependencies in D<sup>+</sup>>that include only attributes of Ri
  - All multivalued dependencies of the form $\alpha \rightarrow\rightarrow> (\beta ∩ R_i$) where \alpha \subseteq Ri and  \alpha \rightarrow\rightarrow \beta is in D<sup>+</sup>


---

### 4NF Decomposition Algorithm

<p><i>result:</i> = {<i>R</i>}; <i>done</i> := false; <i>compute D</i><sup>+</sup>; Let Di denote the restriction of D<sup>+</sup>>to Ri <b>while </b>(<b>not </b><i>done</i>)  <b>if </b>(there is a schema **R**i in <i>result </i>that is not in 4NF) **then** **begin** let \alpha \rightarrow\rightarrow \beta be a nontrivial multivalued dependency that  holds on <i>R</i>i such that \alpha \rightarrow<i> R</i><i>i  </i>is not in <i>D</i>i, and \alpha∩\beta=φ;  <i>result </i>:=  (<i>result </i>-<i> R</i><i>i</i>) \cup (<i>R</i><i>i</i> - \beta)  \cup (\alpha, \beta);  **end** <b>else </b><i>done</i>:= true; Note: each <i>R</i><i>i</i> is in 4NF, and decomposition is lossless-join</p>


---

### Example

- <i>R</i> =(<i>A, B, C, G, H, I</i>)
<p><i>F </i>={ <i>A </i>\rightarrow\rightarrow<i> B</i> <i>B</i> \rightarrow\rightarrow<i> HI</i> <i>CG </i>\rightarrow\rightarrow<i> H</i> }</p>
- <i>R</i> is not in 4NF since <i>A</i> \rightarrow\rightarrow<i> B</i> and <i>A</i> is not a superkey for <i>R</i>
- Decomposition
    a. <i>R</i><i>1</i> = (<i>A, B</i>)  (<i>R</i><i>1</i> is in 4NF)
    b. <i>R</i>2 = (<i>A, C, G, H, I</i>)   (<i>R</i><i>2</i> is not in 4NF, decompose into  R3 and R4)
    c. <i>R</i>3 = (<i>C, G, H</i>)  (<i>R</i>3 is in 4NF) d) <i>R</i><i>4</i> = (<i>A, C, G, I</i>)   (<i>R</i><i>4</i> is not in 4NF, decompose into R5 and  R6)</p>
  - <i>A</i> \rightarrow\rightarrow<i> B</i> and <i>B</i> \rightarrow\rightarrow<i> HI </i><i> A</i> \rightarrow\rightarrow<i> HI</i>, (MVD transitivity), and
  - and hence <i>A</i> \rightarrow\rightarrow<i> I (MVD restriction to R</i><i>4</i><i>)</i> e) <i>R</i><i>5</i> = (<i>A, I</i>)   (<i>R</i><i>5</i> is in 4NF) f)<i>R</i><i>6</i> = (A, C, G)   (R6 is in  4NF)


---

### Further Normal Forms

- <b>Join dependencies</b> generalize multivalued dependencies
  - lead to <b>project-join normal form (PJNF)</b> (also called <b>fifth normal form</b>)
- A class of even more general constraints, leads to a normal form called <b>domain-key normal form</b>.
- Problem with these generalized constraints:  are hard to reason with, and no set of sound and complete set of  inference rules exists.
- Hence rarely used


---

### Overall Database Design Process

- We have assumed schema <i>R</i> is given
  - <i> R</i> could have been generated when converting E-R diagram to a set of tables.
  - <i> R</i> could have been a single relation containing <i>all</i> attributes that are of interest (called <b>universal relation</b>).
  - Normalization breaks <i>R</i> into smaller relations.
  - <i> R</i> could have been the result of some ad hoc design of relations, which we then test/convert to normal form.


---

### ER Model and Normalization

- When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram  should not need further normalization.
- However, in a real (imperfect) design, there can be functional >dependencies from non-key attributes of an entity to other  attributes of the entity</p>
  - Example:  an <i>employee</i> entity with
    - attributes <i>department_name</i> and <i>building</i>, 
    - functional dependency <i>department_name</i>\rightarrow<i> building</i>
    - Good design would have made department an entity
- Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary


---

### Denormalization for Performance

- May want to use non-normalized schema for performance
- For example, displaying <i>prereqs</i> along with <i>course_id, </i>and <i>title</i> requires join of <i>course</i> with <i>prereq</i>
- Alternative 1:  Use denormalized relation containing attributes of <i>course</i> as well as <i>prereq</i> with all above attributes
  - faster lookup
  - extra space and extra execution time for updates
  - extra coding work for programmer and possibility of error in extra code
- Alternative 2: use a materialized view defined as <i>course</i> <i>prereq</i>
  - Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors


---

### Other Design Issues

- Some aspects of database design are not caught by normalization
- Examples of bad database design, to be avoided: 
<p>Instead of <i>earnings </i>(<i>company_id, year, amount </i>), use </p>
  - <i> earnings_2004, earnings_2005, earnings_2006</i>, etc., all on the schema (<i>company_id, earnings</i>).
    - Above are in BCNF, but make querying across years difficult and needs new table each year
  - <i> company_year</i> (<i>company_id, earnings_2004, earnings_2005,  </i>
<p><i>earnings_2006</i>)</p>
    - Also in BCNF, but also makes querying across years difficult and requires new attribute each year.
    - Is an example of a **crosstab**, where values for one attribute become column names
    - Used in spreadsheets, and in data analysis tools


---

### Modeling Temporal Data

- <b>Temporal data</b> have an association time interval during which the data are <i>valid.</i><
- A **snapshot** is the value of the data at a particular point in time
- Several proposals to extend ER model by adding valid time to
  - attributes, e.g., address of an instructor at different points in time
  - entities, e.g., time duration when a student entity exists
  - relationships, e.g., time during which an instructor was associated with a student as an advisor.
- But no accepted standard
- Adding a temporal component results in functional dependencies like <i>ID </i>\rightarrow<i> street, city</i> not holding, because the address varies over time</p>
- A <b>temporal functional dependency</b> X \rightarrow Y holds on schema <i>R</i> if the functional dependency X  Y holds on all snapshots for all legal  instances r (<i>R</i>). t τ


---

### Modeling Temporal Data (Cont.)

- In practice, database designers may add start and end time attributes to relations
  - E.g., <i>course</i>(<i>course_id, course_title</i>) is replaced by <i>course</i>(<i>course_id, course_title, start, end</i>)
    - Constraint: no two tuples can have overlapping valid times
  - Hard to enforce efficiently
- Foreign key references may be to current version of data, or to data at a point in time
  - E.g., student transcript should refer to course information at the time the course was taken


---

### End of Chapter 7



---

### Correctness of 3NF Decomposition Algorithm

- 3NF decomposition algorithm is dependency preserving (since there is a relation for every FD in <i>F</i><i>c</i>)</p>
- Decomposition is lossless
  - A candidate key (<i>C </i>) is in one of the relations <i>R</i><i>i</i> in decomposition
  - Closure of candidate key under <i>F</i><i>c</i> must contain all attributes in $R$.
  - Follow the steps of attribute closure algorithm to show there is only one tuple in the join result for each tuple in<i> R</i><i>i</i>


---

### Correctness of 3NF Decomposition Algorithm (Cont.)

- Claim: if a relation <i>R</i><i>i</i> is in the decomposition generated by the above algorithm, then <i>R</i><i>i</i> satisfies 3NF.
- Proof:
  - Let <i>R</i><i>i</i> be generated from the dependency \alpha \rightarrow \beta
  - Let \gamma \rightarrow B be any non-trivial functional dependency on <i>R</i><i>i</i>. (We need only consider FDs whose right-hand side is a single attribute.)
  - Now, <i>B</i> can be in either \beta or \alpha but not in both. Consider each case separately.


---

### Correctness of 3NF Decomposition (Cont.)

- Case 1: If <i>B</i> in \beta:
   - If \gamma is a superkey, the 2nd condition of 3NF is satisfied
   - Otherwise \alpha must contain some attribute not in \gamma
   - Since \gamma \rightarrow<i> B</i> is in <i>F</i><sup><i>+</i></sup>>it must be derivable from <i>F</i><i>c</i>, by using attribute closure on \gamma.
   - Attribute closure not have used \alpha \rightarrow\beta.  If it had been used, \alpha must be contained in the attribute closure of \gamma, which is not possible, since we assumed \gamma is not a superkey.
   - Now, using \alpha\rightarrow (\beta- {B}) and \gamma \rightarrow<i> B</i>, we can derive \alpha \rightarrow<i>B</i> (since \gamma \subseteq \alpha \beta, and B ∉ \gamma since \gamma \rightarrow<i> B</i> is non-trivial)
   - Then, <i>B</i> is extraneous in the right-hand side of \alpha \rightarrow\beta; which is not possible since \alpha \rightarrow\beta is in Fc.
   - Thus, if <i>B</i> is in \beta then \gamma must be a superkey, and the second condition of 3NF must be satisfied.


---

### Correctness of 3NF Decomposition (Cont.)

- Case 2:  <i>B</i> is in \alpha.
  - Since \alpha is a candidate key, the third alternative in the definition of 3NF is trivially satisfied.
  - In fact, we cannot show that \gamma is a superkey.
  - This shows exactly why the third alternative is present in the definition of 3NF.  Q.E.D.


---

### First Normal Form

- Domain is **atomic** if its elements are considered to be indivisible units
  - Examples of non-atomic domains:
    - Set of names, composite attributes
    - Identification numbers like CS101  that can be broken up into parts
- A relational schema R is in **first normal form** if the domains of all attributes of R are atomic
- Non-atomic values complicate storage and encourage redundant (repeated) storage of data
  - Example:  Set of accounts stored with each customer, and set of owners stored with each account
  - We assume all relations are in first normal form (and revisit this in Chapter 22: Object Based Databases)


---

### First Normal Form (Cont.)

- Atomicity is actually a property of how the elements of the domain are used.
  - Example: Strings would normally be considered indivisible 
  - Suppose that students are given roll numbers which are strings of the form _CS0012_ or _EE1127_
  - If the first two characters are extracted to find the department, the domain of roll numbers is not atomic.
  - Doing so is a bad idea: leads to encoding of information in application program rather than in the database.

