---
title: {{TITLE}}
theme: "comp550"
separator: "^---"
verticalSeparator: "^----"
notesSeparator: "^Note:"
revealOptions:
    transition: fade
---

## Today's notes

 * From the [agenda $\dots$]({{HTTPS_FQDN}}#chapter-1:-overview-of-database-systems)
 * From last time
   - Please use Piazza for communications
      - LA/TAs can answer your questions
      - You will get a much faster response
   - Resubmissions like crazy.  You only get three
   - [Agenda]({{HTTPS_FQDN}}#agenda) &amp; [grades]({{HTTPS_FQDN}}/grades)  determine what's due or submitted
 * {{FRAG}} By the end of class you should understand
     - General idea of what a database is, the levels of abstraction
     - General DBMS data management
     - Databases are critical to most endeavors
 * {{FRAG}} Any questions???


Notes:

---

## Where databases fit into CS

 * In Computer Science we study:
   - Designing programs
      - Syntax, Semantics, Abstraction
   - {{FRAG}} Designing Algorithms
      - Correctness &amp; efficiency
   - {{FRAG}} Designing data
      - Generalization
      - Portability
      - Independence
      - Robustness
   - {{FRAG}} Data sets are growing far faster than either languages used to process them or the algorithms used to manage them.

Note:
There are lots of subjects in an undergraduate CS education.<br/>We study programs and their syntax, semantics, and abstraction.<br/>We design algorithms to be correct and efficient.

This class will talk about designing data and its storage to allow for information generalization in modeling entities.  
Data portability allows data to be stored regardless of the vendor, platform, os being used (consider clouds, records, bytes,etc).
Data Independence allows different levels of the database (logical, physical) to change without affecting other layers
Data robustness means that the system is consistent after crashes, recovery, fault tolerant, etc

---

## What is a database?

 * A very large, integrated collection or _related_&nbsp; bits
 * {{FRAG}} Models real-world enterprise
   - Entities (e.g., students, courses)
   - Relationships (e.g., Brittany is taking COMP 421)
 * {{FRAG}} A <b>Database Management System</b> DBMS is:
   - A software package designed to store and manage databases.

Notes:

P 4.   A database is a collection of data for an organization.
<b>It is not a DBMS!</b>

The data represents entities of an enterprise (bookstore, campus, hospital) and the relationships between the entities.

A DBMS is a software package designed to manage databases.

We’ll be looking at how to design a database and how to use a DBMS.   We will concentrate on relational DBMS.

---

## Files versus databases

 * Application must stage large datasets between main memory and secondary storage
 * Special code for different queries
 * {{FRAG}} Must protect data from inconsistencies caused by multiple concurrent users
 * {{FRAG}} Crash recovery
 * {{FRAG}} Security and access control

Notes:

Page 8

Think about UNC having 20,000 undergraduate, 4,000 faculty, 74 bachelor’s degrees.   What data are you going to keep in memory?

What things are you going to keep in memory?  Payroll?  Courses?  Tenure?

Think about the questions asked by students versus professors versus administrators

Think about protecting students from hacking their grades, outsiders from stealing patents, finding reasons for tenure

What happens if one system goes down

---

## Why use a database?

 * Data independence
    - Arguably the most important
 * {{FRAG}} Efficient access
 * {{FRAG}} Reduced application development time
 * {{FRAG}} Data integrity and security
 * {{FRAG}} Uniform data administration
 * {{FRAG}} Concurrent access, recovery from classes

Note:

We want applications to be written given a certain file format.   The applications should just write the data and let the DBMS and operating system take care of things.

Think about how you would keep track of everything in memory.   Or if you needed to answer a query in a certain amount of time

Standardization allows an application (consider PeopleSoft, SAP) to be written efficiently without knowledge of underlying system.

What happens if an ATM gives you cash, then crashes before deducting the amount from your account?

Think about allowing access to data.  You want security and integrity of the data.  

Data administration allows for admins to set up efficiencies in accessing

Should two administrators be able to update two different students at the same time?

---

## Why Study databases?

 * Shift from **computation** to **information**
   - At the _low end_&nbsp;: dynamic web spaces
   - At the _high end_&nbsp;: scientific applications
 * {{FRAG}} Datasets increasing in diversity and volume
   - Digital libraries, interactive video, Human Genome, Earth-Observing Satellite (EOS)
   - Need for DBMS exploiting
 * {{FRAG}} DBMS encompasses most of CS

Note:

Simple applications are web pages (consider your bank account page looks just like another person’s but with different data) to very complex things that give complex information like scientific applications.

Databases can store digital images, videos, genomic information,etc.   And querying it is done through a DBMS

Very few applications will not use a DBMS at some point.

---

## Data Models

 * **Data model**: collection of concepts relating data
 * {{FRAG}} <b>Schema</b>: particular data organization implementing a data model
 * {{FRAG}} The <b>relational model of data</b> is the most widely used model today.
    - **Relation**: A table with rows and columns
    - Every relation has a **schema** which describes then allowed contents of columns or fields.

Note:

Page 10

<b>Data model</b> that has data description constructs that hide the low-level storage details.   We’ll be focused on the relational data model

A schema is an abstract, high level data model.

A relation is a table of rows and columns.   The schema describes the columns or fields.  We’ll talk about the entity-relationship model later.

---

## Levels of abstraction&nbsp;&nbsp;

<div class="row">
 <div class="column">
   <img src="{{HTTPS_FQDN}}/static/images/levelsOfAbstraction.png" style="float:right; width:25%; position:fixed; top:100px; right:0;"/>
 </div>
 <div>
   <ul>
    <li>Many views</li>
    <li class="fragment">Single conceptual schema</li>
    <li class="fragment">Physical schema</li>
 </div>
</div>

Note:

Page 12

There are generally three levels of abstraction.   The external view of the data, the conceptual view, and the physical view.  All have a schema describing the data

---

## Levels of abstraction&nbsp;&nbsp;

<div class="row">
 <div class="column">
   <ul>
    <li>Schemas are defined using a Data Definition Languages (DDLs)</li>
    <li class="fragment">Data are modified / queried using Data Management Languages (DMLs)</li>
 </div>
 <div class="column">
   <img src="{{HTTPS_FQDN}}/static/images/levelsOfAbstraction.png" style="width:25%; right:0;"/>
 </div>
</div>

Note:

We define the external and conceptual schemas using the DDL.  (CREATE TABLE, DROP, ALTER, TRUNCATE).  The schema information is stored in the system catalog.

Data management language adds, deletes and modifies data in a database.  (INSERT, DELETE, UPDATE)

---

## Example
### University Database

 * Conceptual schema
   - Students(sid: string, name: string, login: string, dob: date, gpa: real)
   - {{FRAG}} Courses(cid: string, cname: string, credits: int)
   - {{FRAG}} Enrolled(sid:string, cid: string, grade: string)

Note:

Page 13

The conceptual or logical schema describes the data in terms of the DBMS data model.

When designing a database, choices are not always obvious.   Should name be first name, last name, etc.  (We will discuss this in chapter 2)

---

## Example
### University Database

 * Physical schema
   - Relations stored as unordered files
   - {{FRAG}} Index on first column 
     - For example, Students(sid)

Note:

Page 14

Once we have the conceptual schema we can get to the physical schema.

For example, we may describe an index which is not part of the conceptual schema.

---

## Example
### University Database

 * External Schema (View)
   - Course_info(cid: string, enrolled: int)

Note:

Page 15

This is the view and authorization at the level of individual users.

So a database has only one conceptual and physical schema.   But since we have lots of users, we have lots of external schema’s or views.

Notice how this course_info is different from course of the conceptual view

---

## Data Independence

 * One of the most important benefits of using DBMS!
 * {{FRAG}} Applications insulated from how data is actually structured and stored
 * {{FRAG}} <b>Logical data independence</b>:
   - Protection from changes in the logical data structure 
 * {{FRAG}} <b>Physical data independence</b>:
   - Protection from changes in physical structure of data

Note:

Page 15

The idea of the independence is that if you change an external view or a logical/conceptual schema, it shouldn’t affect physical schema.

For example, I may change what LAs can view for this class.  It wont change the physical schema.   

For example, we could change the indices for performance reason, but that wouldn’t affect users’ view

---

## Concurrency Control

 * Concurrent execution of multiple user queries is essential for good DBMS performance
 * {{FRAG}} Interleaving actions of different user programs can lead to inconsistency
   - Check is cleared while account balance is being computed
 * {{FRAG}} DBMS ensures such problems don't arise
   - Users pretend they're using a single-user system

Note:

Page 17

Think of all the operations you take for granted as “happening in isolation” even though they are run concurrently.

Think about anything to do with your checking account.

---

## Database Transaction

 * Key concept is of a **transaction** (Xact)
   - An atomic sequence of database actions
 * {{FRAG}} Each transaction, executed completely must
   - Leave the DB in a _consistent state_
   - Only assumes that the transaction started in a consistent state
 * {{FRAG}} Do you know any examples of an inconsistent state?

Note:

Page 17

A transaction is any one execution of a user program in a DBMS.  

Think about paying off your car loan from your checking account.   The transaction cannot remove money from your checking account unless it updates your car loan.  Your car loan should not be paid off until all the transaction complete.

Everything must be left in a consistent state

Debits and credits must balance

The money in the bank drawer must match the starting amount plus deposits and withdrawals

If you drop a course but still get charged for it

---

## Database transactions Con't

 * Users can specify some simple _integrity constraints_&nbsp; on the data, and the DBMS will enforce these constraints.
 * {{FRAG}} Beyond this, the DBMS does not really understand the semantics of the data
    - It does not understand how the interest on a bank account is computed
 * {{FRAG}} Thus, ensuring that a transaction run alone preserves consistency is ultimately the <i>user's</i>&nbsp; responsibility!

Note:

Some ideas of integrity constraints is that bank accounts cannot go less than zero.  Maybe that a department has one and only one manager.

In our class section numbers are integers but there are only two possible values.

The application has to implement the restrictions by committing the data.

---

## Scheduling Concurrent Transactions

 * DBMS ensures that execution of $\{ T_1, \dots , T_n\}$ is equivalent to **some ordered serial execution** of $T_1$, $\dots$, and $T_n$
   - {{FRAG}} Before reading / writing an object
       - A transaction requests a lock on the object
       - Waits until the DBMS gives it the lock
       - All locks are released at the transaction's end
   - {{FRAG}} <b>Idea:</b> If an both $T_i$ and $T_j$ read / write X
       - One Xact, say $T_i$, obtains the lock on X first
       - $T_j$ is forced to wait until $T_i$ completes
       - Effectively orders the transactions
   - {{FRAG}} What if $T_j$ already has a lock on X and $T_i$ later requests a lock on X?
       - {{FRAG}} Deadlock!  $T_i$ or $T_j$ is aborted and restarted.

Note:

P 18

The way the DBMS ensures serial execution of transactions is to ensure it has all the shared or exclusive locks on a table before it start.  All locks are released at the end of the transaction

We’ll consider transaction management later in Chapter 16 and 17

But you should have a general understanding of how deadlock could occur

---

## Ensuring Atomicity

 * DBMS ensure **atomicity** even if system crashes in the middle of a Xact.
     - Atomicity implies all or nothing
 * {{FRAG}} <b>Idea:</b> Keep a log of all actions carried out by the DBMS while executing a set of Xacts:
     - {{FRAG}} <b>Before</b> a change is made to the database, the corresponding log entry is forced to a safe location.
        - Write-Ahead Log (WAL) protocol
     - {{FRAG}} <b>After a crash</b>, the effects of partially executed transactions are undone using the log. 

Note:

Page 18

The idea of atomicity during a system crash is done using a log.

The idea is to keep track of all the transactions in the log BEFORE anything is made to the database.   

{{HTTPS_FQDN}}/worksheets/worksheet-02
---

## The log

 * The following actions are recorded in the log:
      - <b>Ti writes an object</b>:  The old value and the new value.<br />Log record must go to disk <b>before</b> the changed page!
      - <b>Ti commits/aborts</b>:  Log a record of this action.
 * {{FRAG}} Log records chained together by Xact id, so it’s easy to undo a specific Xact (e.g., to resolve a deadlock).
 * {{FRAG}} Log is often duplexed and archived on “stable” storage.
 * {{FRAG}} All log related activities are handled transparently by the DBMS.

Note:

The log will keep the old and the new value so that recovery can be done

The log keeps track of each transaction.

It’s generally keep somewhere else and duplicated.

We’ll cover more of this in chapter 18

---

## Databases make these folks happy

 * End users (Banks, Retailers, Scientists)
 * {{FRAG}} DBMS vendors (Oracle, IBM, Microsoft)
 * {{FRAG}} DB application programmers
 * {{FRAG}} Database administrator (DBA)
     - Designs logical/physical schemas
     - Handles security and authorization
     - Data availability, crash recovery 
     - Database tuning as needs evolve

Note:

It goes without saying that DBA, get paid well

---

## Structure of a DBMS

<div class="row">
 <div class="column">
   <ul>
     <li>A typical DBMS has a layered architecture.</li>
     <li class="fragment">The figure does not show the concurrency control and recovery components.</li>
     <li class="fragment">This is one of several possible architectures; each system has its own variations.</li>
 </div>
 <div class="column">
   <img src="{{HTTPS_FQDN}}/static/images/structure_of_a_dbms.png" style="width:35%; right:0;"/>
 </div>
</div>

Note:

Page 20 has a more detailed architecture.   I recommend that you look at it.

---

## Epilogue

 * DBMS used to maintain, query large datasets.
 * {{FRAG}} Benefits include recovery from system crashes, concurrent access, quick application development, data integrity, and security.
 * {{FRAG}} Levels of abstraction provide data independence.
 * {{FRAG}} A DBMS typically has a layered architecture.
 * {{FRAG}} DBAs hold responsible jobs and are well-paid!

Note:

Database admins are pretty well paid and have a lot of responsibility.

But consider Knight Capital Group that made trades but didn’t have the money to back them.   The company didn’t have controls in place to limit their exposure.

The company lost $440M on $7B stocks in about 45 minutes.  

https://www.henricodolfing.com/2019/06/project-failure-case-study-knight-capital.html


## Epilogue
 
 * Databases are central to most enterprises

 * {{FRAG}} Next time
   - Modeling data
   - The Entity - Relationship (ER) model
   - Read chapter 2 for concepts not diagrams
   - Read chapter 3

