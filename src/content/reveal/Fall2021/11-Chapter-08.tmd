---
title: {{TITLE}}
theme: "comp550"
separator: "^---"
verticalSeparator: "^----"
notesSeparator: "^Note:"
revealOptions:
    transition: fade
---

## Today's notes

 * From the [agenda $\dots$]({{HTTPS_FQDN}}#chapter-8:-overview-of-storage-and-indexing)
 * Chapter 8: Overview of storage and indexing
 * {{FRAG}} By the end of class you should understand
     - File organization alternatives
         - Heap, sorted files, indexes
     - Their costs / benefits
 * {{FRAG}} Midterm 1 is graded {{FRAG}}
     - Median / Average $\approx 75$
 * {{FRAG}} Any questions???


Notes:

---

## Overview of Storage and Indexing

<img src="{{HTTPS_FQDN}}/static/images/Chapter08.BeefChart.png" style="width:35%; right:0"/>

<ul>
 <li>Today we'll learn how the data is cut up</li>
</ul>

Note:

---

## Data on External Storage

 * Solid State Disks, Secure Digital (SD)
   - Non-volatile memory:
   - Block addressable storage device
   - Relatively symmetric R/W speeds
   - Access latency, but number writes limited
 * {{FRAG}} Disks: Can retrieve random <i>page</i>&nbsp; at fixed cost
   - But reading consecutive pages much cheaper
 * {{FRAG}} Tapes: Can only read pages subsequently
   - Cheaper than disks
   - Used for archival storage

---

## File organization
 
 * File organization: A method of arranging a file of records on external storage
   - {{FRAG}} Record id (rid) used to physically locate record
   - {{FRAG}} Indexes are data structures that enable finding records quicker
   - {{FRAG}} Search index keys for given values
 * {{FRAG}} Architecture:
   - Buffer manager stages pages from external storage.
   - Buffer pool of pages in main memory
   - File and index layers call buffer manager

---

## Alternative File Organizations

 * Many alternatives exist
   - Each ideal for some but not all situations
 * {{FRAG}} Heap files: 
   - Random order.
   - Suitable when typical access scan all records
 * {{FRAG}} Sorted files:
   - Best when retrieval typically in some order
   - Also, when only a range of records needed
 * {{FRAG}} Indexes: Organize via trees / hashing
   - Like sorted files (fast)
   - Based on certain values, <i>search keys</i>
   - Updates faster than sorted files

---

## Indexes

 * An index is an auxiliary data structure that accelerates queries using the search key fields of the index.
   - Any subset of relation attributes can be search key
   - A search key not necessarily relation key
 * {{FRAG}} An index contains a collection of data entries
   - Supports efficient retrieval of all data entries $k^*$ with a given value of $k$.
   - {{FRAG}} Given data entry $k^*$, we can find record with key $k$ in at most one disk I/O (later chapters)

---

## Hash-based index

 * Places all records with a common attribute in buckets
 * {{FRAG}} Index is a collection of <i>buckets</i>
   - Bucket = primary page plus possible overflow pages<img src="{{HTTPS_FQDN}}/static/images/Chapter08.HashKey.png" style="width:35%; right:0"/>
   - {{FRAG}} Buckets contain data entries
 * {{FRAG}} Hashing function $r = h(\mbox{key})$
   - Mapping index's search key $\rightarrow$ bucket in which the data entry for the record

---

## Tree-based Index

<img src="{{HTTPS_FQDN}}/static/images/Chapter08.TreeBasedIndex.png" style="width:60%; margin-right:auto; margin-left:auto; display=block"/>

<ul>
 <li>Leaf pages contain <i>data entries</i>&nbsp; doubly linked</li>
 <li class="fragment">Non-leaf pages have <i>index entries</i>&nbsp; used to direct searches
 <img src="{{HTTPS_FQDN}}/static/images/Chapter08.TreeIndexEntry.png" style="width:60; margin-right:auto; margin-left:auto; display=block"/></ul>

Note:

page 280

Note the root node has more than three pointers.  Leaf nodes have multiple data entries

---

## Alternatives Index Organization

 * In data entry $k^*$, store one of the following:
   * Covered more in chapter 13
   1. {{FRAG}} Actual data records with the key $k$ - clustered index
   2. {{FRAG}} &lt;$k$, rid of data record with search key value $k$&gt;
   3. {{FRAG}} &lt;$k$, list of rids of data records with search key $k$&gt;
 * {{FRAG}} Data organization choice is independent of indexing method
   - Clustering indices saves on access<br/>but only 1 clustered index per relation
   - {{FRAG}} Unclustered alternatives trade off uniformity of index entries verses size 

---

## Index Classification

 * Primary Index: Index on a set of fields that includes the primary key
   - All other indexes are secondary indexes
   - Unique index contains a candidate key
 * {{FRAG}} Clustered: Tuples sorted by search key and stored sequentially in data blocks
   - Therefore a file can be clustered on at most one search key
 * {{FRAG}} Unclustered: search keys stored with rids that identify the block containing the associated tuple

Note:

  p 277

---

## Clustered vs. Unclustered Indexes

 * Index type: Hash or Tree
   - Independent of data organization: <br />clustered or unclustered
 * {{FRAG}} To build clustered index, must first sort each page
   - May leave space for future inserts
 * {{FRAG}} Later inserts may create overflow pages
   - Therefore cluster <i>close to</i> sorted

<img src="{{HTTPS_FQDN}}/static/images/Chapter08.ClusteredVsUnclustered.png" style="width:60%; margin-right:auto; margin-left:auto; display=block"/>

---

## Cost / Benefit of indexing

 * Adding an index incurs
   - Storage overhead
   - Maintenance overhead
 * {{FRAG}} Without indexing, searching the file for a particular record would require, on average:
   - $\mbox{Number of Records} \cdot \mbox{Cost to read a record} \cdot \frac{1}{2}$
   - Assume random order<br />Each read equally likely to contain record

---

## Cost model for our analysis

 * We ignore CPU costs
   - **B**: The number of data pages
   - {{FRAG}} <b>R</b>: Number of records per page
   - {{FRAG}} <b>D</b>: Average time to read or write a block
   - {{FRAG}} Measuring number of page I/O's ignores pre-fetching
     - Even I/O costs are approximated
   - {{FRAG}} Average-case analysis<br />based on several simplistic assumptions

<p class="fragment"> Good enough to show the overall trends</p>

---

## Comparing File Organizations

 * Heap file:
   - Random record order
   - Insert at end of file
 * {{FRAG}} Sorted file:
   - Sorted on &lt; age, sal &gt;
 * {{FRAG}} Clustered $B^+$ tree file
   - Clustered on search key &lt; age, sal &gt;
 * {{FRAG}} Heap file with unclustered $B^+$ tree
   - Index on search key &lt; age, sal &gt;
 * {{FRAG}} Heap file with unclustered hash index
   - Index on search key &lt; age, sal &gt;

---

## Operations to Compare

 * Scan: Fetch all records from disk<br/><code>SELECT * FROM Emp</code>
 * {{FRAG}} Equality search<br /><code>SELECT * FROM Emp WHERE Age = 25</code>
 * {{FRAG}} Range selection<br /><code>SELECT * FROM Emp WHERE Age > 30</code>
 * {{FRAG}} Insert a record<br /><code>INSERT INTO Emp (Name, Age, Salary) Values('Jordan', 49, 30000)</code>
 * {{FRAG}} Delete a record<br /><code>DELTE FROM Emp WHERE Name = 'Brislow'</code>

---

## Assumptions in Our Analysis

 * Heap Files:
   - Equality selection is on key w/ exactly one match
 * {{FRAG}} Sorted Files:
   - Files compacted after deletions
 * {{FRAG}} Indexes:
   - Search key overhead = 10% size of record
   - {{FRAG}} Hash: No overflow buckets
     - 80% page occupancy 
     - File size = 1.25 data size
   - {{FRAG}} Tree: 67% occupancy (typical)
     - Implies file size = 1.5 data size
     - Tree Fan-out = F

---

## Assumptions (contd.)

 * Scans:
   - Leaf levels of a tree-index are chained
   - Index data-entries plus actual file scanned for unclustered indexes
 * {{FRAG}} Range searches:
   - We use tree indexes to rest the set of data records fetched, but ignore hash indexes

---

## Cost of Operations

<img src="{{HTTPS_FQDN}}/static/images/Chapter08.CostOfOperations.png" style="width:100%; margin-right:auto; margin-left:auto; display=block"/>

* Several assumptions underlie these (rough) estimates!<br/>For example, assume no cost $C$ per record <br/>We'll cover them in the next few lectures.

---

## Indexes and Workload

 * For each query in the workload
   - Which relations does it access?
   - {{FRAG}} Which attributes are retrieved?
   - {{FRAG}} Which attributes are involved in selection/join conditions?<br/>How selective are the conditions applied likely to be?
 * {{FRAG}} For each update in the workload
   - Which attributes are involved in selction/join conditions?<br />How selective are these conditions likely to be?
   - {{FRAG}} The type of update (<code>INSERT / DELETE / UPDATE</code>) and the attributes that are affected.

---

## Index-Only Plans

 * Some queries can be answered without retrieving any tuples from one or more of the relations involved if a suitable index is available.
 * {{FRAG}} &lt; E.dno &gt; Index stores a count of tuples with the same key<br /><code>Select E.dno, COUNT(*) FROM Emp E GROUP By E.dno</code>
 * {{FRAG}} A tree index on &lt;E.dno, E.sal &gt; would give the answer<br /><code>SELECT E.dno, MIN(E.sal) FROM Emp E GROUP BY E.dno</code>
 * {{FRAG}} &lt;E.age, E.sal &gt; or &lt;E.sal, E.age &gt; Average the index keys<br /><code>SELECT AVG(E.sal) FROM Emp E WHERE E.age=25 and E.sal BETWEEN 30000 AND 50000</code>

Note:

Thus far, we have considered what databases do. In this portion of the course we focus on how databases are implemented and organized. This spans topics from where data is stored, how it is retrieved, and how we can optimize access to it. 

Block oriented devicesâ€¦ they read a block of data at a time.

** Need to update this slide. Add SSD and remove tape. **

---

## Index Example

<img src="{{HTTPS_FQDN}}/static/images/Chapter08.IndexExample1.png" style="transform:scale(4); height:auto; position:absolute; top:250px; left:300px"/>
<img src="{{HTTPS_FQDN}}/static/images/Chapter08.IndexExample2.png" style="transform:scale(4); height:auto; position:absolute; top:250px; left:300px" class="fragment"/>

---

## Summary

 * Alternative file organizations<br/>each suited for different situations
 * {{FRAG}} If selection queries are <i>frequent</i><br />data organization and indices are important
   - Hash based indices
   - Sorted files
   - Tree-ased indices
 * {{FRAG}} An index maps search-keys to associated tuples
 * {{FRAG}} Understanding the workload of an application<br/>and its performance goals<br/>is essential for a good design
