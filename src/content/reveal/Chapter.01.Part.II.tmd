---
title: {{TITLE}}
theme: "comp421"
separator: "^---"
verticalSeparator: "^----"
notesSeparator: "^Note:"
revealOptions:
    transition: fade


---

### Today's class

- From yesterday's class you learned
  - What is a database and a DBMS
  - Why use a DBMS
  - Data models used in DBMS
  - Two database languages
- Today we will finish off chapter 1
  - Different DBMS managers
  - Different DBMS users


Note:

### Outline
 - Database-System Applications
 - Purpose of Database Systems
 - View of Data
 - Database Languages
 - Database Design
 - Database Engine
 - Database Architecture
 - Database Users and Administrators
 - History of Database Systems

https://www.db-book.com/slides-dir/PDF-dir/ch1.pdf

---

### Database Access from Application Program

- non-TC SQL are not as powerful as a universal Turing machine.
- SQL does not support actions such as
  - Input from users
  - Output to displays
  - Network communications
- Use TC language with embedded SQL queries
  - TC language can access database data
  - **Application programs** use SQL to interact with the database

Note:

Since classical SQL is not TC, use application program to interact with the database

Our homeworks will be in Python and use psycopg  to interact with SQL

---

### Database Design

- Logical Design – Deciding on the database schema.
  - Requires a <q>good</q> collection of relation schemas.
  - Business decision – which attributes recorded in the database
  - Computer Science decision
    – What relation schemas should we have
    - How should the attributes be distributed among the various relation schemas?
- Physical Design – Deciding on the physical layout of the database 

Note:

**Section 1.5** Database Design

The logical design looks at what is "good" enough information to model the enterprise.  
 - What attributes of the data should be in the database

The computer science decisions are how to _normalize_ the schema to get good performance.

Design is an iterative process for a database,
the database is always changing.

Want to model the enterprise to have the data mimic the real world  
 - For example, multiple submissions  

Once the logical design is done, physical design completed (file organization Chapter 13)
 
---

### Database Engine / Modules

- DBMS partitioned into modules
  - Each module has its own responsibilities
- High level: DBMS divided into (at least)
  - The storage manager
  - The query processor component
  - The transaction management component

Note:

**Section 1.6** Database Engine

We'll discuss each section at a high level now

---

### Storage Manager

- Interfaces between data stored in the database and the application
  - Responsible for:
    - Interaction with the OS file manager 
    - Efficient storing, retrieving and updating of data
- Storage manager components include:
  - Authorization and integrity manager
  - Transaction manager
  - File manager
  - Buffer manager

Note:

First component: Storage manager 

Storage manager allows you to use Psql or other version of SQL on any platform.  
- Do you care if data is stored in 4K or 8K pages?
- Do you care about little endian or big endian?

Storage manager isolates end users from all of this

Storage manager interfaces with the operating system  

---

### Storage Manager Implementation

- Data structures as part of physical system
  - Data files -- store the database itself
  - Data dictionary -- stores metadata
    - In particular the database schema
  - Indices
    - Provides fast access to data items
    - Index maintains pointers to data items
    - Storage manage maintains the pointers

Note:

In chapter 12, 13 and 14 we'll cover these parts of the storage manager

SM maintains data files (4K or 8K?) 
- The meta data  
- Indices  

---

### Query Processor

- The query processor components include:
  - DDL interpreter: Interprets DDL statements
    - Data definition language  
    - Records the definitions in the data dictionary.
  - DML compiler: translates DML query
    - Data manipulation language
    - Provides an evaluation plan to process query
    - Performs query optimization
      - Picks the lowest cost plan
    - Plan give to evaluation engine
  - Query evaluation engine
    - Executes low-level query plan

Note:

Query processor module processes queries, duh!  
- Processes both DML and DDL

The DDL output gets stored in the data dictionary

The DML compiles the query:  
- Looks at several plans
- Sends low cost plan to engine

Query evaluation executes the plan

**NEXT**  
Let's look at a visual of the query processor


---

{{HIDDEN}}

### Query Processing
 1. Parsing and translation
 2. Optimization
 3. Evaluation

<figure>
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.01.QueryProcessing.png" style="width:50%; margin-bottom: auto;">
 <figcaption>Part of Figure 1.3</figcaption>
</figure>

Note:

This is part of Figure 1.3 which is too hard to examine at one sitting

In this class we will spend a large part of the semester on query evaluation!


---

### Transaction Management

- A **transaction** is a collection of operations 
    - Performs a single, logical function
- **Transaction-management component** ensures
    - The database remains in a consistent (correct) state
    - Recovers from:
      - System failures like power failures &amp; OS crashes
      - Transaction (application coding) failures.
- **Concurrency-control manager** controls interaction among concurrent transactions
    - Ensures the consistency of the database.

Note:

Third manager of the DBMS

Transaction manager covered in chapter 17.  May not get to.

A transaction is a group of operations that go together

Transaction manager makes sure the group completes or backs out incomplete group

Concurrency manager makes users think they have their own machine

---

### Database Architecture
#### Just to name a few


- Centralized databases
  -  One to a few cores, shared memory
- Client-server, 
  - One server machine executes work on behalf of multiple client machines.
- Parallel databases
  - Many core shared memory
  - Shared disk
  - Shared nothing
- Distributed databases
  - Geographical distribution
  - Schema/data heterogeneity

Note:

**SECTION 1.7**

Databases can be set up many different ways.

We'll only be looking a centralized database

See next page

---

{{HIDDEN}} 

### Centralized / Shared-Memory


<figure>
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.01.CentralizedSharedMemory.png" style="width:50%; margin-bottom: auto;">
 <figcaption>Figure 1.3</figcaption>
</figure>


---

### Database Applications

- Two-tier architecture
  - Application resides at the client machine
  - Database on server machine
  - Client / Server model
- Three-tier architecture
  - Client acts as a front end
  - Web-based application
  - Client does not contain any direct database calls.


<figure>
 <img src="{{HTTPS_FQDN}}/static/images/Chapter.01.TwoThreTierArchitectures.png" style="width:50%; margin-bottom: auto;">
 <figcaption>Figure 1.4 Two and three-tier architectures</figcaption>
</figure>

Notes:

Database applications are usually partitioned into two or three parts

A two-tier example is where the database is exposed to a client directly.

A three-tier example is like the class website
 - An added layer with server that interfaces with the serve


---

### Database Administrator

- A person who has central control over the system is called a **database administrator (DBA).**
- Functions of a DBA include:
  - Schema definition
  - Storage structure and access-method definition
  - Schema and physical-organization modification
  - Granting of authorization for data access
  - Routine maintenance
  - Periodically backing up the database
  - Ensuring that enough free disk space is available for normal operations, and upgrading disk space as required
  - Monitoring jobs running on the database 
- Lots of money.  Lots of pressure

Note:

A DBA is responsible for all parts of the database.
In this class we'll be sophisticated users but not full DBA

 
If you're a DBA you'll make lots of money but responsible for all these things

---

{{HIDDEN}}

### History of Database Systems

- 1950s and early 1960s:
  - Data processing using magnetic tapes for storage
  - Tapes provided only sequential access
  - Punched cards for input
- Late 1960s and 1970s:
  - Hard disks allowed direct access to data
  - Network and hierarchical data models in widespread use
  - Ted Codd defines the relational data model
  - Would win the ACM Turing Award for this work
  - IBM Research begins System R prototype
  - UC Berkeley (Michael Stonebraker) begins Ingres prototype
  - Oracle releases first commercial relational database
  - High-performance (for the era) transaction processing

Note:

These next three slides give a quick time line for databases

---

{{HIDDEN}}

### History of Database Systems (Cont.)

- 1980s:
  - Research relational prototypes evolve into commercial systems
  - SQL becomes industrial standard
  - Parallel and distributed database systems
  - Wisconsin, IBM, Teradata
  - Object-oriented database systems
- 1990s:
  - Large decision support and data-mining applications
  - Large multi-terabyte data warehouses
  - Emergence of Web commerce


---

{{HIDDEN}}

### History of Database Systems (Cont.)

- 2000s
  - Big data storage systems
  - Google BigTable, Yahoo PNuts, Amazon, 
  - “NoSQL” systems.
  - Big data analysis: beyond SQL
  - Map reduce and friends
- 2010s
  - SQL reloaded
  - SQL front end to Map Reduce systems
  - Massively parallel database systems
  - Multi-core main-memory databases

---

### Epilogue

- You should know:
  - What a databases is and why it's used
  - We won't build databases
  - What is a relational data model
  - The two languages that make up SQL
  - There are many DBMS managers and we won't cover them all

Note:

{{HTTPS_FQDN}}/pages/worksheets/worksheet-01-models  

{{HTTPS_FQDN}}/worksheets/worksheet-01-models?onyen=student1
